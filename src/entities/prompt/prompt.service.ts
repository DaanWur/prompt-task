import { FailedPromptCreation, SanitizeException } from '@app/exceptions';
import { CACHE_MANAGER } from '@nestjs/cache-manager';
import { Inject, Injectable, Logger } from '@nestjs/common';
import { Cache } from 'cache-manager';
import { ModelSanitizedResponseDto } from 'src/dtos/prompt/model-sanitized-response.dto';
import { PromptDto } from 'src/dtos/prompt/prompt.dto';
import { LlmService } from 'src/llm-model/llm.service';
import { EmailSanitizerCommand } from 'src/sanitizers/email-sanitizer/email-sanitizer-command';
import { Invoker } from 'src/sanitizers/invoker';

@Injectable()
export class PromptService {
  private readonly logger = new Logger(PromptService.name);

  constructor(
    @Inject(CACHE_MANAGER) private cacheManager: Cache,
    private readonly invoker: Invoker,
    private readonly llmService: LlmService,
  ) {}

  /**
   * Creates a prompt by sanitizing the input, generating a response, and sanitizing the response.
   * Caches the result to avoid redundant processing of frequently used prompts.
   * @param promptDto - The prompt data transfer object containing the prompt text.
   * @returns The sanitized response including sanitized emails and prompt.
   */
  async createPrompt(promptDto: PromptDto): Promise<ModelSanitizedResponseDto> {
    const cacheKey = `stored_prompt_${promptDto.prompt}`;

    try {
      // Check if the response is already cached
      const cachedResponse = await this.getCachedResponse(cacheKey);
      if (cachedResponse) {
        return cachedResponse;
      }

      // Sanitize the prompt
      const sanitizedPrompt = await this.sanitizePrompt(promptDto.prompt);
      // Generate a response from the model
      const modelResponse = await this.generateModelResponse(
        sanitizedPrompt.sanitizedPrompt,
      );
      // Sanitize the model's response
      const finalResponse = await this.sanitizeModelResponse(
        modelResponse,
        sanitizedPrompt.emailsSanitized,
      );

      // Cache the final response
      await this.cacheResponse(cacheKey, finalResponse);
      return finalResponse;
    } catch (error) {
      this.handleError(error);
    }
  }

  /**
   * Retrieves a cached response if it exists.
   * @param cacheKey - The key used to store the cached response.
   * @returns The cached response or null if not found.
   */
  private async getCachedResponse(
    cacheKey: string,
  ): Promise<ModelSanitizedResponseDto | null> {
    const cachedResponse =
      await this.cacheManager.get<ModelSanitizedResponseDto>(cacheKey);
    if (cachedResponse) {
      this.logger.log('Returning cached response');
      return cachedResponse;
    }
    return null;
  }

  /**
   * Sanitizes the input prompt.
   * @param prompt - The input prompt to be sanitized.
   * @returns The sanitized prompt and emails.
   */
  private async sanitizePrompt(
    prompt: string,
  ): Promise<ModelSanitizedResponseDto> {
    this.logger.log('Sanitizing prompt');
    const sanitizedResult = await this.sanitize(prompt);
    return {
      emailsSanitized: sanitizedResult.emails,
      sanitizedPrompt: sanitizedResult.sanitizedPrompt,
    };
  }

  /**
   * Generates a response from the model based on the sanitized prompt.
   * @param sanitizedPrompt - The sanitized prompt text.
   * @returns The model's response.
   */
  private async generateModelResponse(
    sanitizedPrompt: string,
  ): Promise<string> {
    this.logger.log('Generating response');
    return this.llmService.generateResponse(sanitizedPrompt);
  }

  /**
   * Sanitizes the model's response.
   * @param modelResponse - The response generated by the model.
   * @param emails - The sanitized emails from the input prompt.
   * @returns The sanitized response including sanitized emails and prompt.
   */
  private async sanitizeModelResponse(
    modelResponse: string,
    emails: string[],
  ): Promise<ModelSanitizedResponseDto> {
    this.logger.log('Sanitizing model response');
    const response = await this.sanitize(modelResponse);
    return {
      emailsSanitized: [...emails, ...response.emails],
      sanitizedPrompt: response.sanitizedPrompt,
    };
  }

  /**
   * Caches the response to avoid redundant processing of frequently used prompts.
   * @param cacheKey - The key used to store the cached response.
   * @param response - The response to be cached.
   */
  private async cacheResponse(
    cacheKey: string,
    response: ModelSanitizedResponseDto,
  ): Promise<void> {
    await this.cacheManager.set(cacheKey, response, 3600); // Cache for 1 hour
  }

  /**
   * Handles errors that occur during the prompt creation process.
   * @param error - The error that occurred.
   * @throws FailedPromptCreation - Throws a custom exception with the error message and stack trace.
   */
  private handleError(error: any): never {
    const message = `Error creating prompt: ${error.message}, stack: ${error.stack}`;
    this.logger.error(message);
    throw new FailedPromptCreation(message);
  }

  /**
   * Sanitizes the given prompt using the configured sanitizer.
   * @param prompt - The prompt to be sanitized.
   * @returns The sanitized result including sanitized emails and prompt.
   * @throws SanitizeException - Throws a custom exception if sanitization fails.
   */
  private async sanitize(prompt: string) {
    try {
      this.invoker.setSanitizer(new EmailSanitizerCommand());
      return this.invoker.sanitizePrompt(prompt);
    } catch (error) {
      const message = `Error sanitizing prompt: ${error.message}, stack: ${error.stack}`;
      this.logger.error(message);
      throw new SanitizeException(error);
    }
  }
}
